# 应用计数


#### 引用计数器
1. 引用计数器占四个字节，每个对象都有自己的引用计数器，是一个整数，表示对象的引用次数，即有多少人在使用这个OC对象。
2. 当创建一个新的对象时，它的引用计数器默认为1；当一个对象的引用计数为0时，对象占用的内存就会被回收。
3. 给对象发送一条retain消息，计数器加1；给对象发送一条release消息，计数器减1；
4. 每当一个对象的引用计数为0时，那么他将被销毁(可能不是立即销毁，什么时候销毁由系统决定)，其占用的内存将被系统回收；当一个对象被销毁时，系统会自动向对象发送一条dealloc消息。若重写dealloc方法则必须在最后调用[super dealloc]。也不要直接调用dealloc方法。

#### 非自动内存管理MRC下单例模式实现
1. 创建一个单例对象的静态实例，并初始化为nil。
2. 创建一个类的类工厂方法，当且仅当这个类的实例为nil时生成一个该类的实例。
3. 实现NSCopying协议，覆盖allocWithZone:方法，确保用户在直接分配和初始化对象时不会产生另一个对象。
4. 覆盖release、autorelease、retain、retainCount方法，以此确保单例的状态。
5. 在多线程的环境中，注意使用@synchronized关键字或GCD确保静态实例被正确的创建和初始化。

#### ARC
1. ARC是Automatic Reference Counting的简称，称之为自动引用计数，是iOS5.0之后推出的内存管理的新特性。
2. 是编译器特性，是Xcode帮我们处理的，当编译器发现alloc、retain等时自动帮我们插入release代码。
3. 本质上还是使用引用计数来管理对象，只是我们在编写代码时，不需要向对象发送release或autorelease方法，也不可以调用delloc方法，编译器会在合适的位置自动给用户生成release消息(autorelease)。
4. GC全程是garbage collection, 内存垃圾回收机制，ARC比GC性能好。iOS开发只支持手动内存管理与ARC, Mac开发支持GC垃圾回收机制，10.8之后弃用了GC, 推荐使用ARC。
5. ARC若内存管理不当的话，同样会存在内存泄漏，例如：ARC中循环引用导致内存不能释放而泄漏，OC对象与CoreFoundation类之间桥接时管理不当也会产生内存泄漏。
6. 不能调用release、retain、autorelease、retainCount。可以重写dealloc但不能调用[super dealloc]。
7. 循环引用中必须有一端使用weak。
8. 如果需要对特定文件开启或关闭ARC，可以在工程选项中选择Targets -> Compile Phases -> Compile Source，在里面找到对应文件，添加flag:
	* 打开ARC: -fobjc-arc。
	* 关闭ARC: -fno-objc-arc。

#### ARC中强指针
1. __strong标示，默认所有的指针都是强指针。
2. 只要有强指针指向一个对象，那么这个对象就不会被释放，只要没有强指针指向对象，那么这个对象就会被立即释放。

#### ARC中弱指针
1. __weak标示。
2. 弱指针不影响对象的回收。
3. 不要对新创建的对象使用弱指针，因为这样的话对象以创建出来就被回收了没有意义。
4. 循环引用中必须要有一个是弱指针。

#### MRC
1. 当需要一个对象时就给这个对象的引用计数器加1，当不再需要这个对象时就将该对象引用计数器减1。
2. setter方法设置新对象时需要对新对象做一次retain操作，当原来的对象不需要了，需要对原来的对象做一次release操作。
3. dealloc方法当一个对象即将被销毁时会调用这个方法，它就相当于对象的遗言，在这里释放其它成员所占用的内存，在释放内存前要先调用[super dealloc]。
4. 循环引用中必须有一端是assign的。

