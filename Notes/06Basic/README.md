# 基础知识点

## 1. #include, #import, @class
* 使用#include与#import效果相同，只是后者不会引起交叉编译，确保头文件只会被导入一次。
* 使用#import会包含这个类的所有信息，包括变量和方法，而@class只是告诉编译器，其后面声明的名称是类的名称，至于这些类是如何定义的，暂时不用考虑，后面会再告诉你。
* 若有很多个头文件都#import了同一个文件，或者这些文件以此被#import，那么一旦最开始的头文件稍有改动，后面引用到这个文件的所有类都需要重新编译一遍，效率是比较低的。
* 能在实现文件中#import就不在头文件中#import，在头文件中尽量使用@class。

## 2. 分类(category)
* 不需要通过增加子类而增加现有类的行为(方法), 且类目中的方法与原始类方法基本没有区别。
* 可以访问原始类的实例变量，但不能添加实例变量。
* 覆盖原始类方法后，原始类的方法没办法调用。
* 名称：原有类的名称(分类名称)，文件名称：原有类的名称+分类名称。
* 分类中使用@property只能生成方法的声明，不能生成方法的实现和成员变量。
* 若多个分类中有相同的方法，最后将使用最后编译的那个分类中的方法(Build Phases -> Compile Sources分类从上往下编译，最下面的最后编译)。
* 调用优先级：分类 -> 原始类 -> 父类。

## 3. 扩展(extension)
* 在.m文件中使用给类增加私有的成员变量和方法。
* 类扩展中小括号中没有内容。

## 4. Delegate, Notification, Block
* delegate与block一般是用于两个对象一对一之间的通信交互，delegate需要定义协议方法，代理对象实现协议方法，并且需要建立代理关系才可以实现通信。
* block更加简洁，类似于C里面的函数指针，都可以作为参数进行传递，用于回调。block可以在方法中定义实现，这样可以访问方法中的局部变量。不需要定义繁琐的协议方法，但是若通信事件比较多的话，建议使用delegate。
* block块中使用了局部对象，则会将此对象retain，引用了当前对象的属性或者方法则会将当前对象retain。为了解决block循环引用，通常将当前对象赋给一个局部变量，并且使用__block关键字修饰该局部变量(__block修饰的局部对象在block块中使用不会retain)，使用该变量访问当前对象的属性和方法。
* Notification主要用于一对多情况下通信，而且对象间不需要建立关系，但是使用通知代码可读性差。

## 5. 事件响应者链
* 响应者链表示一序列的响应者对象。事件被交由第一响应者对象处理，如果第一响应者不处理，事件被沿着响应者链向上传递，交给下一个响应者(nect responder)。
* 通常来说，第一响应者是视图对象或其子类对象，当其被触摸后事件被交由它处理，如果它不处理，事件就会被传递给它的视图控制器对象(如果存在)，然后是它的父视图(superview)对象，以此类推，直到顶层视图。接下来会沿着顶层视图(top view)到窗口(UIWindow)对象再到程序(UIApplication)。如果整个过程都没有响应这个事件，该事件就被丢弃。
* 一般情况下，在响应者链中只要有对象处理事件，事件就停止传递，但有时候可以在视图的响应方法中根据一些条件判断来决定是否需要继续传递事件。
* 当触摸一个视图时，首先系统会捕捉此事件，并为此事件创建一个UIEvent对象，将此对象加入当前应用程序的事件队列中，然后由UIApplication对象从队列中一个一个取出来进行分发，首先分发给UIWindow对象，然后由UIWindow对象分发给触摸的视图对象，也就是第一响应者对象。

## 6. static
* static全局变量只初始化一次，防止在其他文件单元中被引用。
* static局部变量只被初始化一次，下一次依据上一次结果值。
* static函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝。

## 7. 类的私有方法
* 直接在.m文件中写方法实现，不要在.h文件中进行方法声明。
* 在.m文件中定义一个category,在category中声明一些方法，然后在@implementation跟@end之间做方法实现。

## 8. 谓词NSPredicate
* cocoa中提供了NSPredicate类，指定过滤器的条件，将符合条件的对象保留下来。

## 9. SEL
* 是一种代表着方法的签名数据类型，也称它是一个选择器。
* 可用作定义普通的变量，方法行参/实参，方法返回值。

## 10. NSString
* 通过字面的方式(NSString *str = @"abc")创建出来的对象保存在常量区，通过对象方法(NSString *str = [[NSString alloc] initWithUTF8String:"abc"])和类方法(NSString *str = [NSString stringWithFormat:@"abc"])创建出来的对象保存在堆中。

## 11. NSSet、NSArray、NSDictionary区别
* 都属于不可变集合类，在创建完集合类后就不能够对他们进行修改，在集合类里只能添加对象元素不能添加基本数据类型。
* NSSet是一个无序集合，在内存中存储的地址是不连续的，并且添加进去的元素是不可重复的。
* NSArray是一个有序集合，在内存中存储的地址是连续的，添加的元素是可重复的，支持下标访问元素，若想知道一个元素是否存在这个数组当中的话需要遍历整个数组一个个去判断，效率低下。
* NSDictionary是一个无序集合，它的数据存储方式是key value键值对的方式进行存储的，key在整个NSDictionary里是唯一的，如果key发生重复，那么后添加的元素会覆盖之前的。
* 数组结构，查询快，插入慢，每次插入一个元素后边所有角标加1。链表数据结构，查询慢，插入快，手拉手询问形式。

## 12. id和instancetype
* id类型是万能指针，能作为参数，方法的返回类型。
* instancetype只能作为方法的返回类型，并且返回的类型是当前定义类的类类型。

## 其他
* 成员变量是在{}中定义的，属性是使用@property定义的，@property会生成下划线开头的成员变量。




