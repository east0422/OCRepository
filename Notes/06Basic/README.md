# 基础知识点

## 1. #include, #import, @class
* 使用#include与#import效果相同，只是后者不会引起交叉编译，确保头文件只会被导入一次。
* 使用#import会包含这个类的所有信息，包括变量和方法，而@class只是告诉编译器，其后面声明的名称是类的名称，至于这些类是如何定义的，暂时不用考虑，后面会再告诉你。
* 若有很多个头文件都#import了同一个文件，或者这些文件以此被#import，那么一旦最开始的头文件稍有改动，后面引用到这个文件的所有类都需要重新编译一遍，效率是比较低的。
* 能在实现文件中#import就不在头文件中#import，在头文件中尽量使用@class。

## 2. 类目(category)
* 不需要通过增加子类而增加现有类的行为(方法), 且类目中的方法与原始类方法基本没有区别。
* 可以访问原始类的实例变量，但不能添加实例变量。
* 覆盖原始类方法后，原始类的方法没办法调用。

## 3. Delegate, Notification, Block
* delegate与block一般是用于两个对象一对一之间的通信交互，delegate需要定义协议方法，代理对象实现协议方法，并且需要建立代理关系才可以实现通信。
* block更加简洁，类似于C里面的函数指针，都可以作为参数进行传递，用于回调。block可以在方法中定义实现，这样可以访问方法中的局部变量。不需要定义繁琐的协议方法，但是若通信事件比较多的话，建议使用delegate。
* block块中使用了局部对象，则会将此对象retain，引用了当前对象的属性或者方法则会将当前对象retain。为了解决block循环引用，通常将当前对象赋给一个局部变量，并且使用__block关键字修饰该局部变量(__block修饰的局部对象在block块中使用不会retain)，使用该变量访问当前对象的属性和方法。
* Notification主要用于一对多情况下通信，而且对象间不需要建立关系，但是使用通知代码可读性差。

## 4. 事件响应者链
* 响应者链表示一序列的响应者对象。事件被交由第一响应者对象处理，如果第一响应者不处理，事件被沿着响应者链向上传递，交给下一个响应者(nect responder)。
* 通常来说，第一响应者是视图对象或其子类对象，当其被触摸后事件被交由它处理，如果它不处理，事件就会被传递给它的视图控制器对象(如果存在)，然后是它的父视图(superview)对象，以此类推，直到顶层视图。接下来会沿着顶层视图(top view)到窗口(UIWindow)对象再到程序(UIApplication)。如果整个过程都没有响应这个事件，该事件就被丢弃。
* 一般情况下，在响应者链中只要有对象处理事件，事件就停止传递，但有时候可以在视图的响应方法中根据一些条件判断来决定是否需要继续传递事件。
* 当触摸一个视图时，首先系统会捕捉此事件，并为此事件创建一个UIEvent对象，将此对象加入当前应用程序的事件队列中，然后由UIApplication对象从队列中一个一个取出来进行分发，首先分发给UIWindow对象，然后由UIWindow对象分发给触摸的视图对象，也就是第一响应者对象。

## 5. static
* static全局变量只初始化一次，防止在其他文件单元中被引用。
* static局部变量只被初始化一次，下一次依据上一次结果值。
* static函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝。

## 6. 类的私有方法
* 直接在.m文件中写方法实现，不要在.h文件中进行方法声明。
* 在.m文件中定义一个category,在category中声明一些方法，然后在@implementation跟@end之间做方法实现。

## 7. 谓词
* cocoa中提供了NSPredicate类，指定过滤器的条件，将符合条件的对象保留下来。




