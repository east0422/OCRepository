# Foundation

## 1. 单例
* 单例模式节省内存资源，一个应用就一个对象。
* 单例可以存储一些公共的数据，每个对象都能共享，访问，修改。
* 单例在头文件中定义一个类方法，在实现文件中定义一个静态对象用于存储单例对象然后实现类方法获取单例对象，若希望多个alloc获取的也都是该单例对象则重写allocWithZone在其中处理静态对象。

## 2. KVC
* KVC(键值编码)是一种间接访问对象实例变量的机制，该机制可以不需要调用存取方法和变量实例就可以访问对象的实例属性。允许开发者通过Key名直接访问对象的属性，或者给对象的属性赋值，而不需要调用明确的存取方法。这样就可以在运行时动态地访问和修改对象的属性。而不是在编译时确定。
* KVC中的基本调用包括valueForKey:和setValue:forKey:两个方法，它们以字符串的形式向对象发送消息，字符串(key)是关注属性的关键，方法中指定key若没用下划线会自动添加下划线。当属性有set,get方法时若forkey的key跟我们set方法的方法名一样(都没有下划线或都有下划线)，那么会优先调用set方法（get方法一样）。
* KVC还支持指定路径，用点号隔开valueForKeyPath:及setValue:forKeyPath:，若向数组请求一个键值，它实际上会查询数组中的每个对象来查找这个键值，然后将查询结果打包到另一个数组中并返回给你。
* KVC简单运算，可以应用一些字符做简单运算(sum、min、max、avg、count)。
* KVC破坏封装性，不推荐使用。

## 3. KVO内部实现原理
* KVO是基于runtime机制实现的。
* 当某个类的对象第一次被观察时，系统就会在运行期动态地创建该类(Person)的一个派生类/子类(NSKVONotifying_Person)，在这个派生类中重写基类中任何被观察属性的setter方法。派生类在被重写的setter方法实现真正的通知机制。
* 属性变化想要被监听到，需要调用属性对应的set方法更改该属性值而不是直接使用类似下划线方式更改属性值(KVC)。
*  KVO(键值观察)是一种能使得对象获取到其他对象属性变化的通知机制，它能够观察一个对象的KVC key path值的变化。
* 实现KVO键值观察模式，被观察的对象必须使用KVC键值编码来修改它的实例变量，这样才能被观察者观察到。因此，KVC是KVO的基础或者说KVO的实现是建立在KVC的基础之上的。
* 为了正确接受属性的变更通知，观察对象必须首先发送一个addObserver:forKeyPath:options:context:消息至被观察对象，用以传送观察对象和需要观察的属性的关键路径，以便于其注册。
* 当监听的属性发生变动时，观察者收到observeValueForKeyPath:ofObject:change:context:消息,观察者必须实现这一方法。触发观察通知的对象和键路径、包含变更细节的字典，以及观察者注册时提交的上下文指针均被提交给观察者。
* 当不再需要观察时可以发送一条指定观察方对象和键路径的removeObserver:forKeyPath:消息至被观察的对象，来移除一个键值观察者。

## 4. 通知
* NSNotification是iOS中一个调度通知的类，采用单例模式设计，在程序中实现传值、回调等。
* NSNotificationCenter是一个通知中心，采用单例设计，每个应用程序都会有一个默认的通知中心，用于调度通知的发送和接收。
* 如果发送的通知指定了object对象，那么观察者接收的通知设置的object对象与其一样时才会接收到通知。但是接收通知若将这个参数设置为了nil，则会接收所有的通知。
* 观察者的SEL函数指针可以有一个参数，参数就是发送对象本身，可以通过这个参数取到消息对象的userInfo,实现传值。
* 通知有如下缺点：在编译期间不会检查通知是否能够被观察者正确的处理；在释放通知的观察者时，需要在通知中心移除观察者；发送通知和接收通知时需要提前知道通知名称，若通知名称不一致，会出现不同步的情况；通知发送后不能从观察者获得任何的反馈信息；在调试的时候通知传递的过程很难控制和跟踪。

## 5. 可否将比较耗时的操作放在NSNotificationCenter中
* 通知中心所做的操作在主线程，比较耗时的一般开启一个单独线程去跑。
* 若在异步线程发的通知，则可执行比较耗时的操作。
* 若在主线程发的通知，则不可以执行比较耗时的操作。

## 6. Foundation对象与Core Foundation对象区别
* Foundation对象是OC的，Core Foundation对象是C的。
* ARC下桥接: __bridge(F <-> CF), __bridge_retained(F -> CF), __bridge_transfer(CF -> F)。
* MRC: __bridge, 直接强转。

## 7. runtime实现机制
* 运行时机制，是一套C语言库。
* 实际上我们所编写的所有OC代码，最终都是转成了runtime库的东西(比如类转成了runtime库里面的结构体等数据类型，方法转成了runtime库里面的C语言函数，平时调用方法都是转成了objc_msgSend函数)。
* runtime是OC的底层实现，是OC的幕后执行者。
* runtime库里面包含了跟类、成员变量、方法相关的api，可以获取类里面的所有成员变量，为类动态添加成员变量和新的方法，动态改变类的方法实现等。

## 8. 协议
* 一序列方法的列表，其中声明的方法可以被任何类实现，这种模式通常称为代理模式。
* @required表示必须实现的，@optional表示可选的，这两个关键字是在OC2.0后加入的语法特性，若不注明则默认是@required的。
* 可以使用conformsToProtocol判断某个类是否实现了某个protocol。

## 其他
* 动态是在程序运行过程才执行的操作。




