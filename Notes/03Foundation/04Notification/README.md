# Notification


#### 简述
1. NSNotification是iOS中一个调度通知的类，采用单例模式设计，在程序中实现传值、回调等。观察者模式，通常发送者和接收者是间接的多对多关系。消息的发送者告知接收者事件已经发生或将要发生，仅此而已，接收者并不能反过来影响发送者的行为。
2. NSNotificationCenter是一个通知中心，采用单例设计，每个应用程序都会有一个默认的通知中心，用于调度通知的发送和接收。允许当事件发生的时候通知一些对象，满足控制器与一个任意对象进行通信的目的，这种模式的基本特征就是接收到在该controller中发生某种而产生的消息，controller用一个key(通知名称)，这样对于controller是匿名的，其他的使用同样的key来注册了该通知的对象能对通知的事件作出响应。Notification主要用于一对多情况下通信，而且对象间不需要建立关系，但是使用通知代码可读性差。
3. 如果发送的通知指定了object对象，那么观察者接收的通知设置的object对象与其一样时才会接收到通知。但是接收通知若将这个参数设置为了nil，则会接收所有的通知。
4. 观察者的SEL函数指针可以有一个参数，参数就是发送对象本身，可以通过这个参数取到消息对象的userInfo,实现传值。
5. 优点：
	* 不需要写多少代码，实现简单。
	* 一个对象发出的通知，多个对象能进行响应，一对多的方式实现很简单。
6. 缺点：
	* 在编译期间不会检查通知是否能够被观察者正确的处理。
	* 在释放通知的观察者时，需要在通知中心移除观察者；
	* 需要第三方来管理controller和观察者的联系。
	* controller和观察者需要提前知道通知名称、UserInfo dictionary keys。如果这些没有在工作区间定义或通知名称不一致，那么会出现不同步的情况。
	* 通知发出后，发出通知对象不能从观察者获得任何反馈。
	* 在调试的时候通知传递控制流程很难控制和跟踪。

#### 可否将比较耗时的操作放在NSNotificationCenter中
1. 通知中心所做的操作在主线程，比较耗时的一般开启一个单独线程去跑。
2. 若在异步线程发的通知，则可执行比较耗时的操作。
3. 若在主线程发的通知，则不可以执行比较耗时的操作。



