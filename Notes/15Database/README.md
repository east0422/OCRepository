# Database数据库


#### SQLite定义
1. 是一个内嵌式的数据库，数据库服务器就在你的程序中，不需要网络配置和管理。数据库的服务器和客户端运行在同一个进程中，可以减少网络访问的消耗，简化数据库管理，使得程序部署更容易。
2. 后端(Back-end)
	1. 后端由B-tree、页缓冲(page cache，pager)和操作系统接口(即系统调用)构成。B-tree和page cache共同对数据进行管理。它们操作的是数据库页，这些页具有相同的大小，就像集装箱。页里面的"货物"是表示信息的大量bit，这些信息包括记录、字段和索引入口等。B-tree和pager都不知道信息的具体内容，它们只负责"运输"这些页，页不关心这些"集装箱"里面是什么。
	2. B-tree的主要功能就是索引，它维护者各个页之间的复杂的关系，便于快速找到所需数据。它把页组织成树型的结构(这是它名称的由来)，这种树是为了查询而高度优化了的。Page为B-tree服务，为它提供页。Pager的主要作用就是通过OS接口在B-tree和磁盘之间传递页。
	3. 磁盘操作是计算机到目前为止所必须做的最慢的事情。所以，pager尽力提高速度，其方法是把经常使用的页存放到内存当中的页缓冲区里，从而尽量减少操作磁盘的次数。它使用特殊的算法来预测下面要使用哪些页，从而使B-tree能够更快地工作。
3. SQLite会等你真正地向其中增加了数据库对象之后才创建它，比如在其中创建了表或视图。这样做的原因是给你机会在讲数据库写到外部文件之前对数据库做一些永久性的设置(如页的大小等)。有些设置，如页大小、字符集(UTF-8或UFT-16)等，一旦数据库创建之后就不能再修改了。`sqlite3 test.db; create table test(id integer primary key autoincreate, value text);`。
4. 主键约束：在SQLite中，当你定义一个表时总要确定一个主键，不管你自己有没有定义。这个字段是一个64-bit整型字段，称为ROWID。它还有两个别名_ROWID_和OID，用这两个别名同样可以取到它的值。它的默认取值按照增序自动生成。SQLite为主键字段提供自动增长特性(最好自己使用autoincrement指定自增，默认自增新值为last_insert_rowid()+1，若删除最后一个再添加新的id默认还是刚才值)。
5. 存储类：SQLite有5个原始的数据类型，被称为存储类，表面了一个值在磁盘上存储的格式。可以使用typeof()函数查看值对应存储类。
	* INTEGER：整数值是全数字(包括正和负)，SQLite根据数字的值自动控制整数所占的字节数。未用引号括起来的数据并且没有小数点和指数。
	* REAL：实数是10进制的数值，SQLite使用8字节的符点数来存储实数。未用引号括起来的数据并且带有小数点或指数。
	* TEXT：字符数据，字符串的大小没有限制，SQLite支持几种字符编码，包括UTF-8和UTF-16。用单引号或双引号括起来的文字。
	* BLOB：二进制大对象是任意类型的数据，大小没有限制。格式为X'ABCD'的值，其中ABCD为16进制数字。
	* NULL：表示没有值。
	* 具有不同存储类的值可以存储在同一个字段中。不同存储类的值可通过它们各自类的"类值"进行排序：NULL存储类具有最低的类值，一个具有NULL存储类的值比所有其它值都小(包括其它具有NULL存储类的值)，在NULL值之间，没有特别的可排序值。INTEGER或REAL存储类值高于NULL，它们的类值相等，INTEGER值和REAL值通过其数值进行比较。TEXT存储类的值比INTEGER和REAL高，数值永远比字符串的值低，当两个TEXT值进行比较时，其值大小由“排序法”决定。BLOB存储类具有最高的类值，具有BLOB类的值大于其它所有类的值，BLOB值之间在比较时使用C函数memcmp()。当SQLite对一个字段进行排序时，首先按存储类排序，然后再进行类内的排序(NULL类内部各值不必排序)。
6. 亲和性和存储：一个NUMERIC字段可能包括所有5种存储类，一个NUMERIC字段具有数字存储类的偏好(INTEGER和REAL)，当一个TEXT值被插入到一个NUMERIC字段将会试图将其转化为INTEGER存储类；如果转化失败，将会试图将其转化为REAL存储类；若还是失败，将会用TEXT存储类来存储。一个INTEGER字段的处理很像NUMERIC字段，一个INTEGER字段会将REAL值按REAL存储类存储，也就是说，如果这个REAL值没有小数部分，就会被转化为INTEGER存储类。INTEGER字段将会试着将TEXT值按REAL存储；如果转化失败，将会试图将其转化为INTEGER存储类，如还是失败，将会用TEXT存储类来存储。一个TEXT字段将会把所有的INTEGER或REAL值转化为TEXT。一个NONE字段不试图做任何类型转化，所有值按它们本身的存储类存储。没有字段试图向NULL或BLOB值转化，NULL和BLOB值永远都按本来的方式存储所有字段。
7. 事务：事务定义了一组SQL命令的边界，这组命令作为一个整体或者被全部执行或者都不执行。事务由3个命令控制：BEGIN、COMMIT和ROLLBACK。BEGIN开始一个事务，之后的所有操作都可以取消。COMMIT使BEGIN后的所有命令得到确认，而ROLLBACK还原BEGIN之后的所有操作。SQLite默认情况下，每条SQL语句自成事务(自动提交模式)。
8. 数据库锁：在SQLite中，锁和事务是紧密联系的。SQLite使用锁逐步上升机制，为了写数据库，连接需要逐级地获得排它锁，SQLite有5个不同的锁状态，每个数据库连接在同一时刻只能处于其中一个状态，每种状态(未加锁状态除外)都有一种锁与之对应。
	* 未加锁(UNLOCKED)：最初的状态是未加锁状态，在此状态下，连接还没有存取数据库，当连接到了一个数据库，甚至已经用BEGIN开始了一个事务时，连接都还处于未加锁状态。
	* 共享(SHARED)：为了能够从数据库中读(不写)数据，连接必须首先进入共享状态，也就是说首先要获得一个共享锁。多个连接可以同时获得并保持共享锁，也就是说多个连接可以同时从同一个数据库中读数据。但哪怕只有一个共享锁还没有释放，也不允许任何连接写数据库。
	* 保留(RESERVED)：如果一个连接想要写数据库，它必须首先获得一个保留锁，一个数据上同时只能有一个保留锁，保留锁可以与共享锁共存，保留锁是写数据库的第一阶段，保留锁既不阻止其它拥有共享锁的连接继续读数据库，也不阻止其它连接获得新的共享锁。一旦一个连接获得了保留锁，它就可以开始处理数据库修改操作了，尽管这些修改只能在缓冲区中进行，而不是实际地写到磁盘，对读出内容所做的修改保存在内存缓冲区中。
	* 未决(PENDING)：为了得到排它锁还必须首先将保留锁提升为未决锁。获得未决锁之后，其它连接就不能再获得新的共享锁了，但已经拥有共享锁的连接仍然可以继续正常读数据库。此时拥有未决锁的连接等待其它拥有共享锁的连接完成工作并释放其共享锁。一旦所有其它共享锁都被释放，拥有未决锁的连接就可以将其锁提升至排它锁。
	* 排它(EXCLUESIVE)：当连接想要提交修改(或事务)时，需要将保留锁提升为排它锁。当升至排它锁时就可以自由地对数据库进行修改了，所有以前对缓冲区所做的修改都会被写到数据库文件。
9. 事务的种类：SQLite有三种不同的事务，事务类型在BEGIN命令中指定`BEGIN [DEFERRED|IMMEDIATE|EXCLUSIVE] TRANSACTION;`
	* DEFERRED：一个DEFERRED事务不获取任何锁(直到它需要锁的时候)，BEGIN语句本身也不会做什么事情————它开始于UNLOCK状态。默认情况下就是这样的，如果仅仅用BEGIN开始一个事务，那么事务就是DEFERRED的，同时它不会获取任何锁。当对数据库进行第一次读操作时，它会获取SHARED锁。同样，当进行第一次写操作时，它会获取RESERVED锁。
	* IMMEDIATE：由BEGIN开始的IMMEDIATE事务会尝试获取RESERVED锁，如果成功，BEGIN IMMEDIATE保证没有别的连接可以写数据库，但别的连接可以对数据库进行读操作；但是，RESERVED锁会阻止其它连接的BEGIN IMMEDIATE或BEGIN EXCLUSIVE命令，当其它连接执行上述命令时，会返回SQLITE_BUSY错误。这时就可以对数据库进行修改操作了，但是你还不能提交，当你COMMIT时，会返回SQLITE_BUSY错误，这意味着它还有其它的读事务没有完成，得等它们执行完后才能提交事务。
	* EXCLUSIVE：EXCLUSIVE事务会试着获取对数据库的EXCLUSIVE锁，这与IMMEDIATE类似，但是一旦成功，EXCLUSIVE事务保证没有其它的连接，所以就可对数据库进行读写操作了。


