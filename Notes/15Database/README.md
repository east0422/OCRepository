# Database数据库


#### 数据存储
1. Plist：自动存储数组、字典，但是数组和字典里面不能有自定义对象。
2. Preference：偏好设置，NSUserDefaults，常用来保存应用程序设置和属性及用户数据，用户再次打开程序或开机后这些数据仍然存在。NSUserDefaults可以存储的数据类型包括NSData, NSString, NSNumber, NSDate, NSArray, NSDictionary, 其他类型数据需先进行转换，也不能存储自定义对象。
3. 归档：数据对象需要遵守NSCoding协议(NSKeyedArchiver/NSKeyedUnarchiver)，并且该对象对应的类必须提供encodeWithCoder:(告诉系统如何对对象进行编码)和initWithCoder:(告诉系统如何对对象进行解码)方法，存储自定义对象。一次性读取和存储操作，即一次只能读取或存储所有内容。
4. 文件：获得文件保存路径 -> 生成该路径下的文件 -> 往文件中写入数据 -> 从文件中读取数据。
5. SQLite：是一款轻型的嵌入式数据库，占用资源非常的低、在嵌入式设备中只需几百K内存就够了。处理速度比Mysql、PostgreSQL都还快。添加SQLite相关库及头文件 -> 用数据库存取数据(打开数据库，编写数据库语句，执行，关闭数据库。写入数据库字符串可以采用char方式，而从数据库中取出char类型当char类型有表示中文字符时会出现乱码这是因为数据库默认使用ascII编码方式，所以想要正确从数据库中取出中文需要使用NSString来接收从数据库取出的字符串)。
6. Core Data：对SQLite的封装，不需要接触sql语句就可以对数据库进行操作。

#### SQL
1. 增加表字段：ALTER TABLE 表名 ADD COLUMN 字段名 字段类型；
2. 删除表字段：ALTER TABLE 表名 DROP COLUMN 字段名；
3. 修改表字段：ALTER TABLE 表名 RENAME COLUMN 旧字段名 TO 新字段名；

#### SQLite
1. 是一个内嵌式的数据库，数据库服务器就在你的程序中，不需要网络配置和管理。数据库的服务器和客户端运行在同一个进程中，可以减少网络访问的消耗，简化数据库管理，使得程序部署更容易。
2. 后端(Back-end)
	1. 后端由B-tree、页缓冲(page cache，pager)和操作系统接口(即系统调用)构成。B-tree和page cache共同对数据进行管理。它们操作的是数据库页，这些页具有相同的大小，就像集装箱。页里面的"货物"是表示信息的大量bit，这些信息包括记录、字段和索引入口等。B-tree和pager都不知道信息的具体内容，它们只负责"运输"这些页，页不关心这些"集装箱"里面是什么。
	2. B-tree的主要功能就是索引，它维护者各个页之间的复杂的关系，便于快速找到所需数据。它把页组织成树型的结构(这是它名称的由来)，这种树是为了查询而高度优化了的。Page为B-tree服务，为它提供页。Pager的主要作用就是通过OS接口在B-tree和磁盘之间传递页。
	3. 磁盘操作是计算机到目前为止所必须做的最慢的事情。所以，pager尽力提高速度，其方法是把经常使用的页存放到内存当中的页缓冲区里，从而尽量减少操作磁盘的次数。它使用特殊的算法来预测下面要使用哪些页，从而使B-tree能够更快地工作。
3. SQLite会等你真正地向其中增加了数据库对象之后才创建它，比如在其中创建了表或视图。这样做的原因是给你机会在讲数据库写到外部文件之前对数据库做一些永久性的设置(如页的大小等)。有些设置，如页大小、字符集(UTF-8或UFT-16)等，一旦数据库创建之后就不能再修改了。`sqlite3 test.db; create table test(id integer primary key autoincreate, value text);`。
4. 主键约束：在SQLite中，当你定义一个表时总要确定一个主键，不管你自己有没有定义。这个字段是一个64-bit整型字段，称为ROWID。它还有两个别名_ROWID_和OID，用这两个别名同样可以取到它的值。它的默认取值按照增序自动生成。SQLite为主键字段提供自动增长特性(最好自己使用autoincrement指定自增，默认自增新值为last_insert_rowid()+1，若删除最后一个再添加新的id默认还是刚才值)。
5. 存储类：SQLite有5个原始的数据类型，被称为存储类，表面了一个值在磁盘上存储的格式。可以使用typeof()函数查看值对应存储类。
	* INTEGER：整数值是全数字(包括正和负)，SQLite根据数字的值自动控制整数所占的字节数。未用引号括起来的数据并且没有小数点和指数。
	* REAL：实数是10进制的数值，SQLite使用8字节的符点数来存储实数。未用引号括起来的数据并且带有小数点或指数。
	* TEXT：字符数据，字符串的大小没有限制，SQLite支持几种字符编码，包括UTF-8和UTF-16。用单引号或双引号括起来的文字。
	* BLOB：二进制大对象是任意类型的数据，大小没有限制。格式为X'ABCD'的值，其中ABCD为16进制数字。
	* NULL：表示没有值。
	* 具有不同存储类的值可以存储在同一个字段中。不同存储类的值可通过它们各自类的"类值"进行排序：NULL存储类具有最低的类值，一个具有NULL存储类的值比所有其它值都小(包括其它具有NULL存储类的值)，在NULL值之间，没有特别的可排序值。INTEGER或REAL存储类值高于NULL，它们的类值相等，INTEGER值和REAL值通过其数值进行比较。TEXT存储类的值比INTEGER和REAL高，数值永远比字符串的值低，当两个TEXT值进行比较时，其值大小由“排序法”决定。BLOB存储类具有最高的类值，具有BLOB类的值大于其它所有类的值，BLOB值之间在比较时使用C函数memcmp()。当SQLite对一个字段进行排序时，首先按存储类排序，然后再进行类内的排序(NULL类内部各值不必排序)。
6. 亲和性和存储：一个NUMERIC字段可能包括所有5种存储类，一个NUMERIC字段具有数字存储类的偏好(INTEGER和REAL)，当一个TEXT值被插入到一个NUMERIC字段将会试图将其转化为INTEGER存储类；如果转化失败，将会试图将其转化为REAL存储类；若还是失败，将会用TEXT存储类来存储。一个INTEGER字段的处理很像NUMERIC字段，一个INTEGER字段会将REAL值按REAL存储类存储，也就是说，如果这个REAL值没有小数部分，就会被转化为INTEGER存储类。INTEGER字段将会试着将TEXT值按REAL存储；如果转化失败，将会试图将其转化为INTEGER存储类，如还是失败，将会用TEXT存储类来存储。一个TEXT字段将会把所有的INTEGER或REAL值转化为TEXT。一个NONE字段不试图做任何类型转化，所有值按它们本身的存储类存储。没有字段试图向NULL或BLOB值转化，NULL和BLOB值永远都按本来的方式存储所有字段。
7. 事务：事务定义了一组SQL命令的边界，这组命令作为一个整体或者被全部执行或者都不执行。事务由3个命令控制：BEGIN、COMMIT和ROLLBACK。BEGIN开始一个事务，之后的所有操作都可以取消。COMMIT使BEGIN后的所有命令得到确认，而ROLLBACK还原BEGIN之后的所有操作。SQLite默认情况下，每条SQL语句自成事务(自动提交模式)。
8. 数据库锁：在SQLite中，锁和事务是紧密联系的。SQLite使用锁逐步上升机制，为了写数据库，连接需要逐级地获得排它锁，SQLite有5个不同的锁状态，每个数据库连接在同一时刻只能处于其中一个状态，每种状态(未加锁状态除外)都有一种锁与之对应。
	* 未加锁(UNLOCKED)：最初的状态是未加锁状态，在此状态下，连接还没有存取数据库，当连接到了一个数据库，甚至已经用BEGIN开始了一个事务时，连接都还处于未加锁状态。
	* 共享(SHARED)：为了能够从数据库中读(不写)数据，连接必须首先进入共享状态，也就是说首先要获得一个共享锁。多个连接可以同时获得并保持共享锁，也就是说多个连接可以同时从同一个数据库中读数据。但哪怕只有一个共享锁还没有释放，也不允许任何连接写数据库。
	* 保留(RESERVED)：如果一个连接想要写数据库，它必须首先获得一个保留锁，一个数据上同时只能有一个保留锁，保留锁可以与共享锁共存，保留锁是写数据库的第一阶段，保留锁既不阻止其它拥有共享锁的连接继续读数据库，也不阻止其它连接获得新的共享锁。一旦一个连接获得了保留锁，它就可以开始处理数据库修改操作了，尽管这些修改只能在缓冲区中进行，而不是实际地写到磁盘，对读出内容所做的修改保存在内存缓冲区中。
	* 未决(PENDING)：为了得到排它锁还必须首先将保留锁提升为未决锁。获得未决锁之后，其它连接就不能再获得新的共享锁了，但已经拥有共享锁的连接仍然可以继续正常读数据库。此时拥有未决锁的连接等待其它拥有共享锁的连接完成工作并释放其共享锁。一旦所有其它共享锁都被释放，拥有未决锁的连接就可以将其锁提升至排它锁。
	* 排它(EXCLUESIVE)：当连接想要提交修改(或事务)时，需要将保留锁提升为排它锁。当升至排它锁时就可以自由地对数据库进行修改了，所有以前对缓冲区所做的修改都会被写到数据库文件。
9. 事务的种类：SQLite有三种不同的事务，事务类型在BEGIN命令中指定`BEGIN [DEFERRED|IMMEDIATE|EXCLUSIVE] TRANSACTION;`
	* DEFERRED：一个DEFERRED事务不获取任何锁(直到它需要锁的时候)，BEGIN语句本身也不会做什么事情————它开始于UNLOCK状态。默认情况下就是这样的，如果仅仅用BEGIN开始一个事务，那么事务就是DEFERRED的，同时它不会获取任何锁。当对数据库进行第一次读操作时，它会获取SHARED锁。同样，当进行第一次写操作时，它会获取RESERVED锁。
	* IMMEDIATE：由BEGIN开始的IMMEDIATE事务会尝试获取RESERVED锁，如果成功，BEGIN IMMEDIATE保证没有别的连接可以写数据库，但别的连接可以对数据库进行读操作；但是，RESERVED锁会阻止其它连接的BEGIN IMMEDIATE或BEGIN EXCLUSIVE命令，当其它连接执行上述命令时，会返回SQLITE_BUSY错误。这时就可以对数据库进行修改操作了，但是你还不能提交，当你COMMIT时，会返回SQLITE_BUSY错误，这意味着它还有其它的读事务没有完成，得等它们执行完后才能提交事务。
	* EXCLUSIVE：EXCLUSIVE事务会试着获取对数据库的EXCLUSIVE锁，这与IMMEDIATE类似，但是一旦成功，EXCLUSIVE事务保证没有其它的连接，所以就可对数据库进行读写操作了。
10. 基本操作步骤(需先导入libsqlite3框架)
	1. 打开数据库，利用sqlite3_open()打开数据库会指定一个数据库文件保存路径。若文件存在则直接打开，否则创建并打开，打开数据库会得到一个sqlite3类型的对象，后面需要借助这个对象进行其他操作。
	2. 执行SQL语句，执行SQL语句又包括有返回值的语句和无返回值语句。
	3. 对于无返回值的语句(如增加、删除、修改等)直接通过sqlite3_exec()函数执行。
	4. 对于有返回值的语句则首先通过sqlite3_prepare_v2()进行sql语句评估(语法检测)，然后通过sqlite3_step()依次取出查询结果的每一行数据，对于每行数据都可以通过对应的sqlite3_column_类型()方法获得对应列的数据，如此反复循环直到遍历完成。
	5. 最后需要释放句柄。

#### CoreData
1. CoreData是对SQLite数据库的封装，CoreData中有三个对象是必须掌握的。
	1. NSManagedObject:是NSObject的子类，是一个通用类。
		* 实现了CoreData模型层所需的基本功能，用户可以通过NSManagedObject建立自己的数据模型。
		* 只要定义一个类继承于该类就会创建一张与之对应的表，也就是一个继承于该类的类就对应一张表。每一个通过继承该类创建出来的对象，都是该类对应表中的一条数据。
	2. NSManagedObjectContext:用于操作数据库，只要有类它就能对数据库的表进行增删改查。
	3. NSPersistentStoreCoordinator:决定数据存储的位置(SQLite/XML/其它文件中)。
2. Core data本身并不是一个并发安全的架构所以在多线程中实现Core data会有以下问题
	1. CoreData中的NSManagedObjectContext在多线程中不安全。
	2. 如果想要多线程访问CoreData的话，最好的方法是一个线程一个NSManagedObjectContext。
	3. 每个NSManagedObjectContext对象实例都可以使用同一个NSPersistentStoreCoordinator实例，这是因为NSManagedObjectContext会在用NSPersistentStoreCoordinator前上锁。
3. 基本操作步骤
	1. 创建管理上下文。创建管理上下文可以细分为:加载模型文件->指定数据存储路径->创建对应数据类型的存储->创建管理对象上下文并指定存储。经过这几个步骤之后可以得到管理对象上下文NSManagedObjectContext，以后所有的数据操作都由此对象负责。同时如果是第一次创建上下文，Core Data会自动创建存储文件，并根据模型对象创建对应的表结构。
	2. 查询数据。对于有条件的查询，在Core Data中是通过谓词来实现的。首先创建一个请求，然后设置请求条件，最后调用上下文执行请求的方法。
	3. 插入数据。插入数据需要调用实体描述对象NSEntityDescription返回一个实体对象，然后设置对象属性，最后保存当前上下文即可。这里需要主要，增、删、改操作完最后必须调用管理对象上下文的保存方法，否则操作不会执行。
	4. 删除数据。删除数据可以直接调用管理对象上下文的deleteObject方法，删除完保存上下文即可。注意，删除数据前必须先查询到对应对象。
	5. 修改数据。修改数据首先也是取出对应的实体对象，然后通过修改对象的属性，最后保存上下文。


